<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>SMART Charts - More House School</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  :root {
    --blazer-navy: #091825;
    --award-gold: #FF9F1C;
    --sport-blue: #034674;
    --text-primary: #2C3E50;
    --white: #FFFFFF;
    --light-grey: #F8FAFC;
    --border-grey: #E5E7EB;
    --green: #059669;
    --blue: #3b82f6;
    --purple: #8b5cf6;
    --pink: #ec4899;
    --red: #dc2626;
    --orange: #f97316;
  }
  
  * { 
    margin: 0;
    padding: 0;
    box-sizing: border-box; 
  }
  
  body {
    font-family: 'Inter', sans-serif;
    background: #FAFBFC;
    color: var(--text-primary);
    font-size: 14px;
  }
  
  /* Header */
  .page-header {
    background: var(--blazer-navy);
    color: #fff;
    padding: 2rem;
    border-bottom: 4px solid var(--award-gold);
    text-align: center;
  }

  .page-header h1 {
    font-family: 'Playfair Display', serif;
    font-size: 2.5rem;
    margin-bottom: 0;
    font-weight: 700;
    letter-spacing: -0.5px;
  }

  .smart-text {
    color: var(--award-gold);
  }

  .charts-text {
    color: #fff;
    font-weight: 400;
  }

  .page-header p {
    display: none;
  }
  
  /* Controls Bar */
  .controls-bar {
    background: white;
    border-bottom: 1px solid var(--border-grey);
    padding: 1rem 2rem;
    display: flex;
    gap: 1rem;
    align-items: center;
    flex-wrap: wrap;
    justify-content: space-between;
  }
  
  .controls-group {
    display: flex;
    gap: 0.75rem;
    align-items: center;
  }
  
  button {
    border: 1px solid var(--border-grey);
    background: white;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.875rem;
    transition: all 0.2s;
    font-family: 'Inter', sans-serif;
  }
  
  button:hover {
    background: var(--light-grey);
  }
  
  select {
    border: 1px solid var(--border-grey);
    background: white;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.875rem;
    font-family: 'Inter', sans-serif;
  }
  
  .status {
    font-size: 0.875rem;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    background: var(--light-grey);
  }
  
  .status.info { color: var(--blue); }
  .status.success { color: var(--green); }
  .status.error { color: var(--red); }
  
  /* Dashboard Layout */
  .dashboard {
    padding: 2rem;
  }
  
  .summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
  }
  
  .card {
    background: white;
    padding: 1.25rem;
    border-radius: 8px;
    border: 1px solid var(--border-grey);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .card-title {
    font-size: 0.75rem;
    color: #6B7280;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.5rem;
  }
  
  .card-value {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary);
    margin: 0.5rem 0;
  }
  
  .card-trend {
    font-size: 0.875rem;
    color: #6B7280;
  }
  
  .charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 1.5rem;
  }
  
  .chart-card {
    background: white;
    padding: 1.5rem;
    border-radius: 8px;
    border: 1px solid var(--border-grey);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .chart-card.wide {
    grid-column: span 2;
  }
  
  .chart-title {
    font-size: 1rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 1rem;
  }
  
  .chart-container {
    position: relative;
    height: 300px;
  }
  
  .chart-container.tall {
    height: 400px;
  }

  /* Debug info */
  .debug-info {
    background: #FEF3C7;
    border: 1px solid #F59E0B;
    border-radius: 4px;
    padding: 1rem;
    margin: 1rem 2rem;
    font-family: monospace;
    font-size: 0.75rem;
  }

  .debug-info h4 {
    color: #92400E;
    margin-bottom: 0.5rem;
  }

  .debug-info pre {
    background: white;
    padding: 0.5rem;
    border-radius: 4px;
    overflow-x: auto;
  }
  
  @media (max-width: 768px) {
    .charts-grid {
      grid-template-columns: 1fr;
    }
    
    .dashboard {
      padding: 1rem;
    }
    
    .controls-bar {
      padding: 1rem;
    }
  }
</style>
</head>
<body>

<header class="page-header">
  <h1><span class="smart-text">SMART</span> <span class="charts-text">Charts</span></h1>
  <p>Strategic Metrics & Real-Time Analytics</p>
</header>

<div class="controls-bar">
  <div class="controls-group">
    <button onclick="refreshData()">🔄 Refresh Data</button>
    <select id="timeFilter" onchange="applyFilters()">
      <option value="all">All Time</option>
      <option value="7d">Last 7 Days</option>
      <option value="30d" selected>Last 30 Days</option>
      <option value="90d">Last 90 Days</option>
    </select>
  </div>
  <div class="status" id="status">Loading...</div>
</div>

<!-- Debug Information (remove in production) -->
<div class="debug-info" id="debugInfo">
  <h4>Debug Information</h4>
  <pre id="debugOutput">Loading debug data...</pre>
</div>

<main class="dashboard">

  <!-- Summary Cards -->
  <div class="summary-cards">
    <div class="card">
      <div class="card-title">Total Enquiries</div>
      <div class="card-value" id="totalInquiries">0</div>
      <div class="card-trend" id="inquiriesTrend">Loading...</div>
    </div>
    
    <div class="card">
      <div class="card-title">Hot Leads</div>
      <div class="card-value" id="hotLeads">0</div>
      <div class="card-trend">Score ≥ 80</div>
    </div>
    
    <div class="card">
      <div class="card-title">Warm Leads</div>
      <div class="card-value" id="warmLeads">0</div>
      <div class="card-trend">Score 60-79</div>
    </div>
    
    <div class="card">
      <div class="card-title">Avg Response Time</div>
      <div class="card-value" id="avgResponseTime">N/A</div>
      <div class="card-trend" id="responseTimeTrend">Loading...</div>
    </div>
    
    <div class="card">
      <div class="card-title">Conversion Rate</div>
      <div class="card-value" id="conversionRate">0%</div>
      <div class="card-trend">Qualified Leads</div>
    </div>

    <div class="card">
      <div class="card-title">Pipeline Status</div>
      <div class="card-value" id="pipelineStatus">0</div>
      <div class="card-trend" id="pipelineTrend">Active enquiries</div>
    </div>
  </div>

  <!-- Charts Grid -->
  <div class="charts-grid">
    
    <!-- Admissions Funnel -->
    <div class="chart-card wide">
      <h3 class="chart-title">Admissions Funnel - Actual Pipeline Status</h3>
      <div class="chart-container tall">
        <canvas id="funnelChart"></canvas>
      </div>
    </div>

    <!-- Current Pipeline Distribution -->
    <div class="chart-card">
      <h3 class="chart-title">Current Pipeline Distribution</h3>
      <div class="chart-container">
        <canvas id="pipelineChart"></canvas>
      </div>
    </div>

    <!-- Lead Temperature -->
    <div class="chart-card">
      <h3 class="chart-title">Lead Temperature Distribution</h3>
      <div class="chart-container">
        <canvas id="leadTempChart"></canvas>
      </div>
    </div>
    
    <!-- Enquiry Volume Over Time -->
    <div class="chart-card wide">
      <h3 class="chart-title">Enquiry Volume Over Time</h3>
      <div class="chart-container">
        <canvas id="volumeChart"></canvas>
      </div>
    </div>

    <!-- Entry Year Distribution -->
    <div class="chart-card">
      <h3 class="chart-title">Entry Year Distribution</h3>
      <div class="chart-container">
        <canvas id="entryYearChart"></canvas>
      </div>
    </div>

    <!-- Subject Interests -->
    <div class="chart-card">
      <h3 class="chart-title">Top Subject Interests</h3>
      <div class="chart-container">
        <canvas id="subjectsChart"></canvas>
      </div>
    </div>
    
  </div>

</main>

<script>
// Chart instances
const charts = {};

// Data storage
const allData = {
  inquiries: []
};

// Debug logging
const debugLog = (label, data) => {
  console.log(`[DEBUG] ${label}:`, data);
  const debugOutput = document.getElementById('debugOutput');
  if (debugOutput) {
    const currentText = debugOutput.textContent;
    debugOutput.textContent = currentText + '\n' + `${label}: ${JSON.stringify(data, null, 2)}`;
  }
};

// Utility functions
const $ = id => document.getElementById(id);

function updateStatus(message, type = 'info') {
  const statusEl = $('status');
  statusEl.textContent = message;
  statusEl.className = `status ${type}`;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function destroyChart(canvasId) {
  if (charts[canvasId]) {
    try {
      charts[canvasId].destroy();
      delete charts[canvasId];
      // Give Chart.js time to clean up
      const canvas = document.getElementById(canvasId);
      if (canvas) {
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
      }
    } catch (e) {
      console.warn(`Failed to destroy chart ${canvasId}:`, e);
      delete charts[canvasId];
    }
  }
}

// FIXED: Calculate engagement score properly
function getScore(inquiry) {
  if (!inquiry) return 0;
  
  // Check if engagement object exists
  if (inquiry.engagement && typeof inquiry.engagement.engagementScore === 'number') {
    return inquiry.engagement.engagementScore;
  }
  
  // Fallback calculation
  const timeOnPage = inquiry.dwell_ms || 0;
  const visits = inquiry.return_visits || 0;
  
  let score = 0;
  if (timeOnPage > 0) score += Math.min(40, timeOnPage / 1000); // Up to 40 points for time
  if (visits > 0) score += Math.min(30, visits * 10); // Up to 30 points for visits
  if (inquiry.prospectus_generated) score += 20; // 20 points for prospectus
  if (inquiry.status && inquiry.status !== 'received') score += 10; // 10 points for action taken
  
  return Math.min(100, score);
}

// Check if date is recent
function isRecent(dateStr, days) {
  if (!dateStr) return false;
  const date = new Date(dateStr);
  const now = new Date();
  const diffDays = (now - date) / (1000 * 60 * 60 * 24);
  return diffDays <= days;
}

// Load all data from API
async function loadAllData() {
  try {
    updateStatus('Loading enquiry data...', 'info');
    
    const response = await fetch('/api/analytics/inquiries?_ts=' + Date.now(), { 
      cache: 'no-store' 
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (!Array.isArray(data)) {
      throw new Error('Invalid data format received');
    }
    
    allData.inquiries = data;
    
    // Debug logging
    debugLog('Total enquiries loaded', allData.inquiries.length);
    
    // Count statuses for debugging
    const statusCounts = {};
    allData.inquiries.forEach(i => {
      const status = i.status || 'received';
      statusCounts[status] = (statusCounts[status] || 0) + 1;
    });
    debugLog('Status counts', statusCounts);
    
    // Sample enquiry for debugging
    if (allData.inquiries.length > 0) {
      debugLog('Sample enquiry', {
        id: allData.inquiries[0].id,
        status: allData.inquiries[0].status,
        received_at: allData.inquiries[0].received_at,
        updated_at: allData.inquiries[0].updated_at,
        prospectus_generated: allData.inquiries[0].prospectus_generated,
        engagement: allData.inquiries[0].engagement
      });
    }
    
    updateStatus(`✓ Loaded ${allData.inquiries.length} enquiries`, 'success');
    
  } catch (error) {
    console.error('❌ Data loading error:', error);
    updateStatus('Error: ' + error.message, 'error');
    throw error;
  }
}

// FIXED: Render Summary Cards with accurate calculations
function renderSummaryCards() {
  const inquiries = allData.inquiries;
  
  if (!inquiries || inquiries.length === 0) {
    $('totalInquiries').textContent = '0';
    $('inquiriesTrend').textContent = 'No data';
    $('hotLeads').textContent = '0';
    $('warmLeads').textContent = '0';
    $('avgResponseTime').textContent = 'N/A';
    $('responseTimeTrend').textContent = 'No data';
    $('conversionRate').textContent = '0%';
    $('pipelineStatus').textContent = '0';
    return;
  }
  
  // Total enquiries
  $('totalInquiries').textContent = inquiries.length;
  const recent30 = inquiries.filter(i => isRecent(i.received_at, 30)).length;
  $('inquiriesTrend').textContent = `${recent30} in last 30 days`;
  
  // Hot and warm leads based on engagement score
  const hotLeads = inquiries.filter(i => getScore(i) >= 80);
  const warmLeads = inquiries.filter(i => {
    const score = getScore(i);
    return score >= 60 && score < 80;
  });
  
  $('hotLeads').textContent = hotLeads.length;
  $('warmLeads').textContent = warmLeads.length;
  
  // FIXED: Average response time calculation
  // Only count enquiries where status changed to actual contact (not just prospectus generation)
  const respondedInquiries = inquiries.filter(i => {
    // Must have a status that indicates REAL contact (not just automated prospectus)
    const contactStatuses = ['contacted', 'high-interest', 'tour-booked', 'open-day-booked', 
                            'application-started', 'application-complete', 'not-interested'];
    return i.status && contactStatuses.includes(i.status);
  });
  
  debugLog('Responded enquiries', {
    total: inquiries.length,
    responded: respondedInquiries.length,
    prospectus_sent: inquiries.filter(i => i.status === 'prospectus_generated').length,
    truly_contacted: respondedInquiries.length
  });
  
  if (respondedInquiries.length > 0) {
    // Calculate response times for truly contacted enquiries only
    const responseTimes = respondedInquiries.map(i => {
      const received = new Date(i.received_at);
      const responded = new Date(i.updated_at || i.received_at);
      return (responded - received) / (1000 * 60 * 60); // hours
    }).filter(hours => hours >= 0); // Filter out negative values
    
    if (responseTimes.length > 0) {
      const avgHours = responseTimes.reduce((sum, h) => sum + h, 0) / responseTimes.length;
      const avgDays = Math.floor(avgHours / 24);
      const remainingHours = Math.round(avgHours % 24);
      
      if (avgDays > 0) {
        $('avgResponseTime').textContent = `${avgDays}d ${remainingHours}h`;
      } else {
        $('avgResponseTime').textContent = `${remainingHours}h`;
      }
      
      // Calculate % within 24h
      const within24h = responseTimes.filter(h => h <= 24).length;
      const pct24h = Math.round((within24h / responseTimes.length) * 100);
      $('responseTimeTrend').textContent = `${pct24h}% within 24h (${respondedInquiries.length} contacted)`;
    } else {
      $('avgResponseTime').textContent = 'N/A';
      $('responseTimeTrend').textContent = 'No valid response times';
    }
  } else {
    $('avgResponseTime').textContent = 'No contacts yet';
    $('responseTimeTrend').textContent = `${inquiries.filter(i => i.status === 'prospectus_generated').length} awaiting contact`;
  }
  
  // Conversion rate (qualified leads)
  const qualified = hotLeads.length + warmLeads.length;
  const conversionRate = inquiries.length > 0
    ? Math.round((qualified / inquiries.length) * 100)
    : 0;
  $('conversionRate').textContent = `${conversionRate}%`;
  
  // Active pipeline (not including 'not-interested' and counting prospectus_sent separately)
  const activePipeline = inquiries.filter(i => i.status !== 'not-interested').length;
  const awaitingContact = inquiries.filter(i => i.status === 'prospectus_generated').length;
  const trulyContacted = inquiries.filter(i => {
    const contactStatuses = ['contacted', 'high-interest', 'tour-booked', 'open-day-booked', 
                            'application-started', 'application-complete'];
    return i.status && contactStatuses.includes(i.status);
  }).length;
  
  $('pipelineStatus').textContent = `${trulyContacted}/${inquiries.length}`;
  $('pipelineTrend').textContent = `${awaitingContact} awaiting contact`;
}

// FIXED: Admissions Funnel with accurate status counts
function renderFunnelChart() {
  const inquiries = allData.inquiries;
  
  // Map all possible statuses - treating prospectus_generated as 'new' since it's not a real contact
  const statusMapping = {
    'received': 'New Enquiry',
    'prospectus_generated': 'Prospectus Sent',  // Separate category for clarity
    'new': 'New Enquiry',
    'contacted': 'Contacted',
    'high-interest': 'High Interest',
    'tour-booked': 'Tour Booked',
    'open-day-booked': 'Open Day',
    'application-started': 'Application Started',
    'application-complete': 'Application Complete',
    'not-interested': 'Not Interested'
  };
  
  // Count by actual status
  const statusCounts = {};
  inquiries.forEach(i => {
    const status = i.status || 'received';
    const displayStatus = statusMapping[status] || 'New Enquiry';
    statusCounts[displayStatus] = (statusCounts[displayStatus] || 0) + 1;
  });
  
  debugLog('Funnel status counts', statusCounts);
  
  // Define funnel stages in order
  const stages = [
    { name: 'New Enquiry', color: '#6B7280' },
    { name: 'Prospectus Sent', color: '#8B5CF6' },  // Purple for prospectus sent
    { name: 'Contacted', color: '#034674' },
    { name: 'High Interest', color: '#FF9F1C' },
    { name: 'Tour Booked', color: '#f97316' },
    { name: 'Open Day', color: '#ec4899' },
    { name: 'Application Started', color: '#059669' },
    { name: 'Application Complete', color: '#10B981' },
    { name: 'Not Interested', color: '#dc2626' }
  ];
  
  // Build chart data
  const labels = [];
  const data = [];
  const colors = [];
  
  stages.forEach(stage => {
    const count = statusCounts[stage.name] || 0;
    if (count > 0) {
      labels.push(stage.name);
      data.push(count);
      colors.push(stage.color);
    }
  });
  
  destroyChart('funnelChart');
  charts.funnelChart = new Chart($('funnelChart'), {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Families',
        data: data,
        backgroundColor: colors,
        borderWidth: 0
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${Math.round(ctx.parsed.x)} families`
          }
        }
      },
      scales: {
        x: { 
          beginAtZero: true,
          grid: { display: false },
          ticks: { 
            precision: 0,
            callback: value => Math.round(value)
          }
        },
        y: { grid: { display: false } }
      }
    }
  });
}

// NEW: Current Pipeline Distribution Chart
function renderPipelineChart() {
  const inquiries = allData.inquiries;
  
  // Group by status - properly handling prospectus_generated
  const statusGroups = {
    'New': inquiries.filter(i => !i.status || i.status === 'received' || i.status === 'new'),
    'Prospectus Sent': inquiries.filter(i => i.status === 'prospectus_generated'),
    'Contacted': inquiries.filter(i => i.status === 'contacted'),
    'Interested': inquiries.filter(i => i.status === 'high-interest' || i.status === 'tour-booked' || i.status === 'open-day-booked'),
    'Applying': inquiries.filter(i => i.status === 'application-started' || i.status === 'application-complete'),
    'Not Interested': inquiries.filter(i => i.status === 'not-interested')
  };
  
  const labels = Object.keys(statusGroups);
  const data = labels.map(label => statusGroups[label].length);
  
  debugLog('Pipeline distribution', {
    New: statusGroups['New'].length,
    'Prospectus Sent': statusGroups['Prospectus Sent'].length,
    Contacted: statusGroups['Contacted'].length,
    Interested: statusGroups['Interested'].length,
    Applying: statusGroups['Applying'].length,
    'Not Interested': statusGroups['Not Interested'].length
  });
  
  destroyChart('pipelineChart');
  charts.pipelineChart = new Chart($('pipelineChart'), {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: ['#6B7280', '#8B5CF6', '#034674', '#FF9F1C', '#059669', '#dc2626'],
        borderWidth: 2,
        borderColor: '#fff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom'
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
              const pct = total > 0 ? Math.round((ctx.parsed / total) * 100) : 0;
              return `${ctx.label}: ${Math.round(ctx.parsed)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

// Lead Temperature Chart
function renderLeadTempChart() {
  const inquiries = allData.inquiries;
  
  const hotLeads = inquiries.filter(i => getScore(i) >= 80);
  const warmLeads = inquiries.filter(i => {
    const score = getScore(i);
    return score >= 60 && score < 80;
  });
  const coldLeads = inquiries.filter(i => getScore(i) < 60);
  
  destroyChart('leadTempChart');
  charts.leadTempChart = new Chart($('leadTempChart'), {
    type: 'doughnut',
    data: {
      labels: ['Hot (≥80)', 'Warm (60-79)', 'Cold (<60)'],
      datasets: [{
        data: [hotLeads.length, warmLeads.length, coldLeads.length],
        backgroundColor: ['#dc2626', '#FF9F1C', '#3b82f6'],
        borderWidth: 2,
        borderColor: '#fff'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom'
        },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
              const pct = total > 0 ? Math.round((ctx.parsed / total) * 100) : 0;
              return `${ctx.label}: ${Math.round(ctx.parsed)} (${pct}%)`;
            }
          }
        }
      }
    }
  });
}

// Volume Chart
function renderVolumeChart() {
  const inquiries = allData.inquiries;
  
  if (!inquiries || inquiries.length === 0) return;
  
  // Group by date
  const dateCounts = {};
  inquiries.forEach(i => {
    if (!i.received_at) return;
    const date = new Date(i.received_at).toISOString().split('T')[0];
    dateCounts[date] = (dateCounts[date] || 0) + 1;
  });
  
  const sortedDates = Object.keys(dateCounts).sort();
  if (sortedDates.length === 0) return;
  
  const firstDate = new Date(sortedDates[0]);
  const lastDate = new Date(sortedDates[sortedDates.length - 1]);
  
  // Fill missing dates
  const allDates = [];
  const allCounts = [];
  
  for (let d = new Date(firstDate); d <= lastDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split('T')[0];
    allDates.push(dateStr);
    allCounts.push(dateCounts[dateStr] || 0);
  }
  
  const displayLabels = allDates.map(date => {
    const d = new Date(date);
    return d.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
  });
  
  destroyChart('volumeChart');
  charts.volumeChart = new Chart($('volumeChart'), {
    type: 'line',
    data: {
      labels: displayLabels,
      datasets: [{
        label: 'Enquiries',
        data: allCounts,
        borderColor: '#034674',
        backgroundColor: 'rgba(3, 70, 116, 0.1)',
        borderWidth: 2,
        fill: true,
        tension: 0.4,
        pointRadius: 4,
        pointHoverRadius: 6,
        pointBackgroundColor: '#034674',
        pointBorderColor: '#fff',
        pointBorderWidth: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            title: (items) => {
              const idx = items[0].dataIndex;
              return allDates[idx];
            },
            label: (ctx) => {
              const count = Math.round(ctx.parsed.y);
              return count === 1 ? '1 enquiry' : `${count} enquiries`;
            }
          }
        }
      },
      scales: {
        y: { 
          beginAtZero: true,
          grid: { color: '#F8FAFC' },
          ticks: { 
            precision: 0,
            callback: value => Math.round(value)
          }
        },
        x: { 
          grid: { display: false },
          ticks: {
            maxRotation: 45,
            minRotation: 45
          }
        }
      }
    }
  });
}

// Entry Year Chart
function renderEntryYearChart() {
  const inquiries = allData.inquiries;
  
  const yearCounts = {};
  inquiries.forEach(i => {
    const year = i.entry_year || 'Not specified';
    yearCounts[year] = (yearCounts[year] || 0) + 1;
  });
  
  const sortedYears = Object.keys(yearCounts).sort();
  const data = sortedYears.map(year => yearCounts[year]);
  
  destroyChart('entryYearChart');
  charts.entryYearChart = new Chart($('entryYearChart'), {
    type: 'bar',
    data: {
      labels: sortedYears,
      datasets: [{
        label: 'Enquiries',
        data: data,
        backgroundColor: '#034674',
        borderWidth: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        y: { 
          beginAtZero: true,
          ticks: { 
            precision: 0,
            callback: value => Math.round(value)
          }
        }
      }
    }
  });
}

// Subject Interests Chart
function renderSubjectsChart() {
  const inquiries = allData.inquiries;
  
  const subjects = [
    'sciences', 'mathematics', 'english', 'languages', 'humanities',
    'drama', 'music', 'art', 'sport'
  ];
  
  const subjectCounts = {};
  subjects.forEach(subject => {
    subjectCounts[subject] = inquiries.filter(i => i[subject]).length;
  });
  
  // Sort by count and take top 5
  const sortedSubjects = Object.entries(subjectCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);
  
  const labels = sortedSubjects.map(([subject]) => 
    subject.charAt(0).toUpperCase() + subject.slice(1)
  );
  const data = sortedSubjects.map(([, count]) => count);
  
  destroyChart('subjectsChart');
  charts.subjectsChart = new Chart($('subjectsChart'), {
    type: 'bar',  // Changed from 'horizontalBar' to 'bar' with indexAxis
    data: {
      labels: labels,
      datasets: [{
        label: 'Interest Count',
        data: data,
        backgroundColor: '#FF9F1C',
        borderWidth: 0
      }]
    },
    options: {
      indexAxis: 'y',  // This makes it horizontal in Chart.js 3+
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        x: { 
          beginAtZero: true,
          ticks: { 
            precision: 0,
            callback: value => Math.round(value)
          }
        }
      }
    }
  });
}

// Render all charts
function renderAllCharts() {
  // Destroy all existing charts first to prevent conflicts
  Object.keys(charts).forEach(chartId => {
    destroyChart(chartId);
  });
  
  // Small delay to ensure cleanup is complete
  setTimeout(() => {
    renderFunnelChart();
    renderPipelineChart();
    renderLeadTempChart();
    renderVolumeChart();
    renderEntryYearChart();
    renderSubjectsChart();
  }, 50);
}

// Apply filters
function applyFilters() {
  const timeFilter = $('timeFilter').value;
  // For now, just re-render with current data
  // In future, could filter data based on timeFilter value
  renderSummaryCards();
  renderAllCharts();
}

// Refresh data
async function refreshData() {
  try {
    updateStatus('Refreshing data...', 'info');
    
    // Clear debug output
    const debugOutput = document.getElementById('debugOutput');
    if (debugOutput) {
      debugOutput.textContent = 'Loading debug data...';
    }
    
    await loadAllData();
    renderSummaryCards();
    renderAllCharts();
    
    setTimeout(() => updateStatus('Ready', 'info'), 3000);
    
  } catch (error) {
    console.error('❌ Refresh error:', error);
    updateStatus('Error: ' + error.message, 'error');
  }
}

// Initialize on load
window.addEventListener('DOMContentLoaded', () => {
  refreshData();
});

// Auto-refresh every 30 seconds
setInterval(() => {
  refreshData();
}, 30000);
</script>

</body>
</html>